import { RouteInspector } from '../debug/inspector';
import { Input, MatchedValue, Matcher, MatchingProp, Nullable, ProcessInputResult, Route, RouteParams, RoutePath, RoutingState, Session } from '../models';
export declare class Router {
    routes: Route[];
    routeInspector: RouteInspector;
    constructor(routes: Route[], routeInspector?: RouteInspector | undefined);
    /**
     * Processes an input and return a representation of the new bot state.
     * The algorithm is splitted in two main parts:
     * 1. Getting the current routing state.
     * 2. Given a routing state, resolve the different possible scenarios and return the new bot state.
     * The new bot state can return three type of actions:
     * - action: an action directly resolved from a matching route
     * - emptyAction: optional action that can exists or not only within childRoutes
     * - fallbackAction: any other action that acts as a fallback (404, )
     */
    processInput(input: Input, session: Session, lastRoutePath?: RoutePath): ProcessInputResult;
    /**
     * Find the route that matches the given input, if it match with some of the entries, return the whole Route of the entry with optional params captured if matcher was a regex.
     * IMPORTANT: It returns a cloned route instead of the route itself to avoid modifying original routes and introduce side effects
     * */
    getRoute(input: Input | Partial<Input>, routes: Route[], session: Session, lastRoutePath: RoutePath): RouteParams | null;
    /**
     * Find the route that matches the given path. Path can include concatenations, e.g: 'Flow1/Subflow1.1'.
     * IMPORTANT: It returns a cloned route instead of the route itself to avoid modifying original routes and introduce side effects
     * */
    getRouteByPath(path: RoutePath, routeList?: Route[]): Nullable<Route>;
    /**
     * Returns the matched value for a specific route.
     * Matching Props: ('text' | 'payload' | 'intent' | 'type' | 'input' | 'session' | 'request' ...)
     * Matchers: (string: exact match | regex: regular expression match | function: return true)
     * input: user input object, e.g.: {type: 'text', data: 'Hi'}
     * */
    matchRoute(route: Route, prop: MatchingProp, matcher: Matcher, input: Input, session: Session, lastRoutePath: RoutePath): MatchedValue;
    /**
     * Runs the matcher against the given value.
     * If there is a match, it will return a truthy value (true, RegExp result), o.w., it will return a falsy value.
     * */
    matchValue(matcher: Matcher, value: any): MatchedValue;
    /**
     * It resolves the current state of navigation. Two scenarios:
     * 1. Given a path payload input (__PATH_PAYLOAD__somePath?someParam=someValue), we can resolve the routing state directly from it (using getRouteByPath).
     * 2. Given any other type of input, we resolve the routing state with normal resolution (using getRoute).
     * */
    getRoutingState(input: Input, session: Session, lastRoutePath: RoutePath): RoutingState;
    /**
     * Given a non path payload input, try to run it against the routes, update matching routes information in consequence and dictamine if the flow has been broken.
     * */
    getRoutingStateFromInput(currentRoute: Nullable<Route>, input: Input, session: Session): RoutingState;
    /**
     * Given a path payload input, try to run the path against the routes, update matching routes information in consequence and dictamine if the flow has been broken.
     * */
    getRoutingStateFromPathPayload(currentRoute: Nullable<Route>, pathPayload: string): RoutingState;
}
