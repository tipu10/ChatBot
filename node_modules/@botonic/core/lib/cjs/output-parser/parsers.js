"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseContact = exports.parseForm = exports.parseMissed = exports.parseCustom = exports.parseCarousel = exports.parseElement = exports.parseLocation = exports.parseMedia = exports.parsePostback = exports.parseText = exports.parseReplies = exports.parseReply = exports.parseButtons = exports.parseButton = exports.parseMessage = exports.parseBoolean = exports.parseNumber = void 0;
const models_1 = require("../models");
const botonic_output_parser_1 = require("./botonic-output-parser");
function parseNumber(strNumber) {
    return parseInt(strNumber);
}
exports.parseNumber = parseNumber;
function parseBoolean(strNumber) {
    if (strNumber === '0')
        return false;
    return true;
}
exports.parseBoolean = parseBoolean;
// COMMON
const parseMessage = args => {
    const typingAndDelay = {};
    if (args.toParse.delay !== undefined) {
        typingAndDelay['delay'] = parseNumber(args.toParse.delay);
    }
    if (args.toParse.typing !== undefined) {
        typingAndDelay['typing'] = parseNumber(args.toParse.typing);
    }
    return {
        toParse: args.toParse,
        parsed: Object.assign({ 
            // Following properties added later before saving event: eventId, userId, createdAt, from, ack
            eventType: models_1.EventTypes.MESSAGE, type: args.toParse.type, ack: args.toParse.ack, from: args.toParse.from }, typingAndDelay),
    };
};
exports.parseMessage = parseMessage;
// BUTTONS
const parseButton = (button) => {
    const title = button[botonic_output_parser_1.TEXT_NODE_NAME];
    if ('payload' in button) {
        return { title, payload: button.payload };
    }
    if ('url' in button) {
        const b = { title, url: button.url, target: button.target };
        if (button.target)
            b.target = button.target;
        return b;
    }
    if ('webview' in button) {
        return {
            title,
            webview: button.webview,
            params: button.params,
        };
    }
    throw new Error('Invalid parsed Button');
};
exports.parseButton = parseButton;
const parseButtons = args => {
    var _a, _b;
    const hasButtons = ((_b = (_a = args.toParse) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.length) > 0;
    let buttons = [];
    if (hasButtons) {
        buttons = args.toParse.button.map(button => (0, exports.parseButton)(button));
    }
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { buttons }),
    };
};
exports.parseButtons = parseButtons;
// REPLIES
const parseReply = (reply) => ({
    title: reply[botonic_output_parser_1.TEXT_NODE_NAME],
    payload: reply.payload,
});
exports.parseReply = parseReply;
const parseReplies = args => {
    var _a, _b;
    const hasReplies = ((_b = (_a = args.toParse) === null || _a === void 0 ? void 0 : _a.reply) === null || _b === void 0 ? void 0 : _b.length) > 0;
    let replies = [];
    if (hasReplies) {
        replies = args.toParse.reply.map(reply => (0, exports.parseReply)(reply));
    }
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { replies }),
    };
};
exports.parseReplies = parseReplies;
// TEXT
const parseText = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { text: args.toParse[botonic_output_parser_1.TEXT_NODE_NAME], markdown: parseBoolean(args.toParse.markdown) }),
    };
};
exports.parseText = parseText;
// POSTBACK
const parsePostback = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { payload: args.toParse.payload }),
    };
};
exports.parsePostback = parsePostback;
// MEDIA
const parseMedia = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { src: args.toParse.src }),
    };
};
exports.parseMedia = parseMedia;
// LOCATION
const parseLocation = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { lat: args.toParse.lat, long: args.toParse.long }),
    };
};
exports.parseLocation = parseLocation;
// CAROUSEL
const parseElement = (element) => {
    const e = {
        pic: element.pic,
        title: element.title,
        subtitle: element.desc,
    };
    const hasButtons = element.button !== undefined;
    if (hasButtons)
        e.buttons = element.button.map(b => (0, exports.parseButton)(b));
    return e;
};
exports.parseElement = parseElement;
const parseCarousel = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { elements: args.toParse.element.map(element => (0, exports.parseElement)(element)) }),
    };
};
exports.parseCarousel = parseCarousel;
// CUSTOM
const parseCustom = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { json: JSON.parse(args.toParse.json) }),
    };
};
exports.parseCustom = parseCustom;
// MISSED
const parseMissed = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { reason: args.toParse.reason, media_type: args.toParse.media_type }),
    };
};
exports.parseMissed = parseMissed;
// FORM
const parseForm = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { form_title: args.toParse.form_title, form_answers: args.toParse.form_answers }),
    };
};
exports.parseForm = parseForm;
// CONTACT
const parseContact = args => {
    return {
        toParse: args.toParse,
        parsed: Object.assign(Object.assign({}, args.parsed), { phone_number: args.toParse.phone_number, first_name: args.toParse.first_name, last_name: args.toParse.last_name, vcard: args.toParse.vcard }),
    };
};
exports.parseContact = parseContact;
//# sourceMappingURL=parsers.js.map