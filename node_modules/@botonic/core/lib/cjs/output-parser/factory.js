"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageParsingFactory = void 0;
const models_1 = require("../models");
const parsers_1 = require("./parsers");
class MessageParsingFactory {
    parse(msgToParse) {
        const type = msgToParse.type;
        const parsedMessage = (0, parsers_1.parseMessage)({ toParse: msgToParse });
        if (models_1.MEDIA_TYPES.includes(type)) {
            return (0, parsers_1.parseMedia)((0, parsers_1.parseButtons)(parsedMessage)).parsed;
        }
        switch (type) {
            case models_1.MessageEventTypes.TEXT:
                // statement 1
                return (0, parsers_1.parseText)((0, parsers_1.parseReplies)((0, parsers_1.parseButtons)(parsedMessage))).parsed;
            case models_1.MessageEventTypes.POSTBACK:
                return (0, parsers_1.parsePostback)(parsedMessage).parsed;
            case models_1.MessageEventTypes.LOCATION:
                return (0, parsers_1.parseLocation)(parsedMessage).parsed;
            case models_1.MessageEventTypes.CAROUSEL:
                return (0, parsers_1.parseCarousel)(parsedMessage).parsed;
            case models_1.MessageEventTypes.CUSTOM:
                return (0, parsers_1.parseCustom)((0, parsers_1.parseReplies)(parsedMessage)).parsed;
            case models_1.MessageEventTypes.FORM:
                return (0, parsers_1.parseForm)(parsedMessage).parsed;
            case models_1.MessageEventTypes.CONTACT:
                return (0, parsers_1.parseContact)(parsedMessage).parsed;
            case models_1.MessageEventTypes.MISSED:
                return (0, parsers_1.parseMissed)(parsedMessage).parsed;
        }
        throw new Error(`Parsing for type: '${type}' not implemented.`);
    }
}
exports.MessageParsingFactory = MessageParsingFactory;
//# sourceMappingURL=factory.js.map