"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreBot = void 0;
const ulid_1 = require("ulid");
const debug_1 = require("./debug");
const i18n_1 = require("./i18n");
const models_1 = require("./models");
const output_parser_1 = require("./output-parser");
const plugins_1 = require("./plugins");
const routing_1 = require("./routing");
class CoreBot {
    constructor({ 
    // TODO: Receives dataProvider
    renderer, routes, locales, theme, plugins, appId, defaultTyping, defaultDelay, defaultRoutes, inspector, }) {
        this.botonicOutputParser = new output_parser_1.BotonicOutputParser();
        this.renderer = renderer;
        this.plugins = plugins_1.loadPlugins(plugins);
        this.theme = theme || {};
        this.defaultTyping =
            typeof defaultTyping !== 'undefined' ? defaultTyping : 0.6;
        this.defaultDelay = typeof defaultDelay !== 'undefined' ? defaultDelay : 0.4;
        this.locales = locales;
        if (appId) {
            this.appId = appId;
            return;
        }
        this.rootElement = null;
        this.inspector = inspector || new debug_1.Inspector();
        this.routes = routes;
        this.defaultRoutes = defaultRoutes || [];
        this.router =
            this.routes instanceof Function
                ? null
                : new routing_1.Router([...this.routes, ...this.defaultRoutes], this.inspector.routeInspector);
    }
    getString(id, session) {
        // @ts-ignore
        return i18n_1.getString(this.locales, session.__locale, id);
    }
    setLocale(locale, session) {
        session.__locale = locale;
    }
    async input({ input, session, lastRoutePath, dataProvider, }) {
        session = session || {};
        if (!session.__locale)
            session.__locale = 'en';
        const parsedUserEvent = this.botonicOutputParser.parseFromUserInput(input);
        const userId = session.user.id;
        if (dataProvider) {
            // TODO: Next iterations. Review cycle of commited events to DB when messages change their ACK
            // @ts-ignore
            const userEvent = await dataProvider.saveEvent(Object.assign(Object.assign({}, parsedUserEvent), { userId, eventId: ulid_1.ulid(), createdAt: new Date().toISOString(), from: models_1.MessageEventFrom.USER, ack: models_1.MessageEventAck.RECEIVED }));
        }
        if (this.plugins) {
            await plugins_1.runPlugins(this.plugins, 'pre', input, session, lastRoutePath, undefined, undefined, dataProvider);
        }
        if (this.routes instanceof Function) {
            this.router = new routing_1.Router([
                ...(await routing_1.getComputedRoutes(this.routes, {
                    input,
                    session,
                    lastRoutePath,
                })),
                ...this.defaultRoutes,
            ], this.inspector.routeInspector);
        }
        const output = this.router.processInput(input, session, lastRoutePath);
        const request = {
            getString: stringId => this.getString(stringId, session),
            setLocale: locale => this.setLocale(locale, session),
            session: session || {},
            params: output.params || {},
            input: input,
            plugins: this.plugins,
            defaultTyping: this.defaultTyping,
            defaultDelay: this.defaultDelay,
            lastRoutePath,
            dataProvider,
        };
        const response = await this.renderer({
            request,
            actions: [output.fallbackAction, output.action, output.emptyAction],
        });
        let messageEvents = [];
        try {
            messageEvents = this.botonicOutputParser.xmlToMessageEvents(response);
        }
        catch (e) {
            // Disabling Botonic 1.0 error log for LTS version:
            // console.error(e)
        }
        lastRoutePath = output.lastRoutePath;
        if (this.plugins) {
            await plugins_1.runPlugins(this.plugins, 'post', input, session, lastRoutePath, response, messageEvents, dataProvider);
        }
        if (dataProvider) {
            // TODO: save bot responses to db and update user with new session and new params
            for (const messageEvent of messageEvents) {
                // @ts-ignore
                const botEvent = await dataProvider.saveEvent(Object.assign(Object.assign({}, messageEvent), { userId, eventId: ulid_1.ulid(), createdAt: new Date().toISOString(), from: models_1.MessageEventFrom.BOT, ack: models_1.MessageEventAck.SENT }));
            }
        }
        session.is_first_interaction = false;
        return {
            input,
            response,
            messageEvents,
            session,
            lastRoutePath,
            dataProvider,
        };
    }
}
exports.CoreBot = CoreBot;
//# sourceMappingURL=core-bot.js.map