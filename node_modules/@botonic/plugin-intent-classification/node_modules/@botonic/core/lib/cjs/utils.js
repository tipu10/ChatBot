"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dirname = exports.join = exports.params2queryString = exports.cloneObject = exports.isFunction = exports.isMobile = exports.getWebpackEnvVar = exports.isBrowser = exports.isNode = void 0;
const isNode = () => {
    // @ts-ignore
    return typeof IS_NODE !== 'undefined'
        ? // @ts-ignore
            IS_NODE
        : typeof process !== 'undefined' &&
            process.versions !== null &&
            process.versions.node !== null;
};
exports.isNode = isNode;
const isBrowser = () => {
    // @ts-ignore
    return typeof IS_BROWSER !== 'undefined'
        ? // @ts-ignore
            IS_BROWSER
        : typeof window !== 'undefined' &&
            typeof window.document !== 'undefined' &&
            !window.process;
};
exports.isBrowser = isBrowser;
function getWebpackEnvVar(webpackEnvVar, name, defaultValue) {
    return (webpackEnvVar ||
        (typeof process !== 'undefined' && process.env[name]) ||
        defaultValue);
}
exports.getWebpackEnvVar = getWebpackEnvVar;
const isMobile = (mobileBreakpoint = 460) => {
    if (exports.isBrowser()) {
        const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        if (w < mobileBreakpoint) {
            return true;
        }
    }
    return false;
};
exports.isMobile = isMobile;
function isFunction(o) {
    return typeof o === 'function';
}
exports.isFunction = isFunction;
function cloneObject(object) {
    if (!object)
        return {};
    return Object.assign({}, object);
}
exports.cloneObject = cloneObject;
const params2queryString = (params) => Object.entries(params)
    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    .join('&');
exports.params2queryString = params2queryString;
// Joins path segments.  Preserves initial "/" and resolves ".." and "."
// Does not support using ".." to go above/outside the root.
// This means that join("foo", "../../bar") will not resolve to "../bar"
const join = (...segments) => {
    // Split the inputs into a list of path commands.
    let parts = [];
    for (let i = 0, l = segments.length; i < l; i++) {
        parts = parts.concat(segments[i].split('/'));
    }
    // Interpret the path commands to get the new resolved path.
    const newParts = [];
    for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        // Remove leading and trailing slashes
        // Also remove "." segments
        if (!part || part === '.')
            continue;
        // Interpret ".." to pop the last segment
        if (part === '..')
            newParts.pop();
        // Push new path segments.
        else
            newParts.push(part);
    }
    // Preserve the initial slash if there was one.
    // @ts-ignore
    if (parts[0] === '')
        newParts.unshift('');
    // Turn back into a single string path.
    return newParts.join('/') || (newParts.length ? '/' : '.');
};
exports.join = join;
// A simple function to get the dirname of a path
// Trailing slashes are ignored. Leading slash is preserved.
const dirname = (path) => exports.join(path, '..');
exports.dirname = dirname;
//# sourceMappingURL=utils.js.map