"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComputedRoutes = exports.getNotFoundAction = exports.getEmptyAction = exports.pathParamsToParams = exports.getPathParamsFromPathPayload = exports.isPathPayload = exports.NoMatchingRouteError = void 0;
const constants_1 = require("../constants");
class NoMatchingRouteError extends Error {
    constructor(input) {
        super(`No route found for input '${JSON.stringify(input)}' and no ${constants_1.NOT_FOUND_PATH} route defined`);
        this.input = input;
    }
}
exports.NoMatchingRouteError = NoMatchingRouteError;
function isPathPayload(payload) {
    if (!payload)
        return false;
    const isPathPayload = constants_1.PATH_PAYLOAD_REGEXP.exec(payload);
    return Boolean(isPathPayload);
}
exports.isPathPayload = isPathPayload;
function getPathParamsFromPathPayload(payload) {
    const defaultPathParams = {
        path: null,
        params: {},
    };
    if (!payload)
        return defaultPathParams;
    if (!isPathPayload(payload))
        return defaultPathParams;
    try {
        const pathWithParams = payload.split(constants_1.PATH_PAYLOAD_IDENTIFIER)[1];
        if (!pathWithParams) {
            throw `${constants_1.PATH_PAYLOAD_IDENTIFIER} is empty`;
        }
        const [path, params] = pathWithParams.split('?');
        return { path: path !== null && path !== void 0 ? path : null, params: pathParamsToParams(params) };
    }
    catch (e) {
        console.error('Error getting path and params from input.payload:', e);
        return defaultPathParams;
    }
}
exports.getPathParamsFromPathPayload = getPathParamsFromPathPayload;
function pathParamsToParams(pathParams) {
    if (!pathParams)
        return {};
    try {
        const params = {};
        const searchParams = new URLSearchParams(pathParams);
        for (const [key, value] of searchParams) {
            params[key] = value;
        }
        return params;
    }
    catch (e) {
        return {};
    }
}
exports.pathParamsToParams = pathParamsToParams;
function getEmptyAction(childRoutes) {
    if (!childRoutes)
        return null;
    const emptyActionRoute = childRoutes.find(r => r.path === constants_1.EMPTY_ACTION_PATH);
    if (!emptyActionRoute)
        return null;
    return emptyActionRoute.action;
}
exports.getEmptyAction = getEmptyAction;
function getNotFoundAction(input, routes) {
    const notFoundActionRoute = routes.find(r => r.path === constants_1.NOT_FOUND_PATH);
    if (!notFoundActionRoute)
        throw new NoMatchingRouteError(input);
    return notFoundActionRoute.action;
}
exports.getNotFoundAction = getNotFoundAction;
async function getComputedRoutes(routes, request) {
    if (routes instanceof Function) {
        return await getComputedRoutes(await routes(request), request);
    }
    for (const [key, route] of Object.entries(routes)) {
        if (route.childRoutes && route.childRoutes instanceof Function) {
            routes[key].childRoutes = await getComputedRoutes(await route.childRoutes(request), request);
        }
        else {
            routes[key] = route;
        }
    }
    return routes;
}
exports.getComputedRoutes = getComputedRoutes;
//# sourceMappingURL=router-utils.js.map