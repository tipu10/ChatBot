"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollbarController = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _dom = require("../../util/dom");

var _ = require(".");

var debounced = function debounced(delay, fn) {
  var timerId;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (timerId) {
      clearTimeout(timerId);
    }

    timerId = setTimeout(function () {
      fn.apply(void 0, args);
      timerId = null;
    }, delay);
  };
};

var stopAtScrollLimit = function stopAtScrollLimit(element) {
  if (element.scrollTop === 0) element.scrollTop = 1;
  if (element.scrollHeight - element.scrollTop === element.clientHeight) element.scrollTop -= 1;
};

var ScrollbarController = /*#__PURE__*/function () {
  function ScrollbarController(currentDevice, host) {
    (0, _classCallCheck2["default"])(this, ScrollbarController);
    this.currentDevice = currentDevice;
    this.webchat = (0, _dom.getWebchatElement)(host);
  }

  (0, _createClass2["default"])(ScrollbarController, [{
    key: "handleScrollEvents",
    value: function handleScrollEvents() {
      var _this = this;

      /*
        It handles scroll events for Mobile/Desktop.
        "ontouchmove" is the phone equivalent for "onmouseover"
      */
      if ((0, _.isMobileDevice)()) {
        if (this.currentDevice !== _.DEVICES.MOBILE.IPHONE) return;
        this.limitScrollBoundaries();

        this.webchat.ontouchstart = function (e) {
          _this.handleOnTouchMoveEvents(e);
        };

        this.webchat.ontouchmove = function (e) {
          _this.handleOnTouchMoveEvents(e);
        };
      } else {
        this.webchat.onmouseover = function (e) {
          return _this.handleOnMouseOverEvents(e);
        };
      }
    }
  }, {
    key: "hasScrollbar",
    value: function hasScrollbar() {
      var scrollableArea = (0, _dom.getScrollableArea)(this.webchat);
      var isScrollable = scrollableArea.visible.clientHeight - scrollableArea.full.clientHeight < 0;
      return isScrollable;
    }
  }, {
    key: "handleOnMouseOverEvents",
    value: function handleOnMouseOverEvents(e) {
      var target = e.currentTarget;

      while (target) {
        this.toggleOnMouseWheelEvents();
        target = target.parentNode;
      }
    }
  }, {
    key: "toggleOnMouseWheelEvents",
    value: function toggleOnMouseWheelEvents() {
      var scrollableContent = (0, _dom.getScrollableContent)(this.webchat);

      if (this.hasScrollbar()) {
        scrollableContent.onmousewheel = {};
        return;
      }

      scrollableContent.onmousewheel = function (e) {
        return e.preventDefault();
      };
    }
  }, {
    key: "handleOnTouchMoveEvents",
    value: function handleOnTouchMoveEvents(e) {
      this.toggleOnTouchMoveEvents();
    }
  }, {
    key: "toggleOnTouchMoveEvents",
    value: function toggleOnTouchMoveEvents() {
      if (this.hasScrollbar()) {
        this.webchat.ontouchmove = {};
        this.webchat.ontouchstart = {};
        return;
      }

      this.webchat.ontouchmove = function (e) {
        if (e.target === e.currentTarget) e.preventDefault();
      };
    }
  }, {
    key: "limitScrollBoundaries",
    value: function limitScrollBoundaries() {
      if (this.currentDevice !== _.DEVICES.MOBILE.IPHONE) return;
      /*
        It adds a bounce effect when top or bottom limits of the scrollbar are reached for iOS,
        as an alternative of overscroll-behavior (https://developer.mozilla.org/en-US/docs/Web/CSS/overscroll-behavior)
      */

      var frame = (0, _dom.getScrollableArea)(this.webchat).visible;
      var dStopAtScrollLimit = debounced(100, stopAtScrollLimit);

      if (frame) {
        if (window.addEventListener) {
          frame.addEventListener('scroll', function () {
            return dStopAtScrollLimit(frame);
          }, true);
        } else if (window.attachEvent) {
          frame.attachEvent('scroll', function () {
            return dStopAtScrollLimit(frame);
          });
        }
      }
    }
  }]);
  return ScrollbarController;
}();

exports.ScrollbarController = ScrollbarController;
//# sourceMappingURL=scrollbar-controller.js.map