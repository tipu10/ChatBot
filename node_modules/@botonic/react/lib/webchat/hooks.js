"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useComponentVisible = useComponentVisible;
exports.useComponentWillMount = void 0;
exports.usePrevious = usePrevious;
exports.useTyping = useTyping;
exports.useWebchat = useWebchat;
exports.webchatInitialState = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = require("react");

var _constants = require("../constants");

var _dom = require("../util/dom");

var _actions = require("./actions");

var _webchatReducer = require("./webchat-reducer");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var webchatInitialState = {
  width: _constants.WEBCHAT.DEFAULTS.WIDTH,
  height: _constants.WEBCHAT.DEFAULTS.HEIGHT,
  messagesJSON: [],
  messagesComponents: [],
  replies: [],
  latestInput: {},
  typing: false,
  webview: null,
  webviewParams: null,
  session: {
    user: null
  },
  lastRoutePath: null,
  handoff: false,
  theme: {
    headerTitle: _constants.WEBCHAT.DEFAULTS.TITLE,
    brandColor: _constants.COLORS.BOTONIC_BLUE,
    brandImage: _constants.WEBCHAT.DEFAULTS.LOGO,
    triggerButtonImage: undefined,
    textPlaceholder: _constants.WEBCHAT.DEFAULTS.PLACEHOLDER,
    style: {
      fontFamily: _constants.WEBCHAT.DEFAULTS.FONT_FAMILY
    }
  },
  themeUpdates: {},
  error: {},
  online: true,
  devSettings: {
    keepSessionOnReload: false
  },
  isWebchatOpen: false,
  isEmojiPickerOpen: false,
  isPersistentMenuOpen: false,
  isCoverComponentOpen: false,
  isCustomComponentRendered: false,
  lastMessageUpdate: undefined,
  currentAttachment: undefined,
  jwt: null
};
exports.webchatInitialState = webchatInitialState;

function useWebchat() {
  var _useReducer = (0, _react.useReducer)(_webchatReducer.webchatReducer, webchatInitialState),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      webchatState = _useReducer2[0],
      webchatDispatch = _useReducer2[1];

  var addMessage = function addMessage(message) {
    return webchatDispatch({
      type: _actions.ADD_MESSAGE,
      payload: message
    });
  };

  var addMessageComponent = function addMessageComponent(message) {
    return webchatDispatch({
      type: _actions.ADD_MESSAGE_COMPONENT,
      payload: message
    });
  };

  var updateMessage = function updateMessage(message) {
    return webchatDispatch({
      type: _actions.UPDATE_MESSAGE,
      payload: message
    });
  };

  var updateReplies = function updateReplies(replies) {
    return webchatDispatch({
      type: _actions.UPDATE_REPLIES,
      payload: replies
    });
  };

  var updateLatestInput = function updateLatestInput(input) {
    return webchatDispatch({
      type: _actions.UPDATE_LATEST_INPUT,
      payload: input
    });
  };

  var updateTyping = function updateTyping(typing) {
    return webchatDispatch({
      type: _actions.UPDATE_TYPING,
      payload: typing
    });
  };

  var updateWebview = function updateWebview(webview, params) {
    return webchatDispatch({
      type: _actions.UPDATE_WEBVIEW,
      payload: {
        webview: webview,
        webviewParams: params
      }
    });
  };

  var updateSession = function updateSession(session) {
    webchatDispatch({
      type: _actions.UPDATE_SESSION,
      payload: session
    });
  };

  var updateLastRoutePath = function updateLastRoutePath(path) {
    return webchatDispatch({
      type: _actions.UPDATE_LAST_ROUTE_PATH,
      payload: path
    });
  };

  var updateHandoff = function updateHandoff(handoff) {
    return webchatDispatch({
      type: _actions.UPDATE_HANDOFF,
      payload: handoff
    });
  };

  var updateTheme = function updateTheme(theme) {
    var themeUpdates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    var payload = themeUpdates !== undefined ? {
      theme: theme,
      themeUpdates: themeUpdates
    } : {
      theme: theme
    };
    webchatDispatch({
      type: _actions.UPDATE_THEME,
      payload: payload
    });
  };

  var updateDevSettings = function updateDevSettings(settings) {
    return webchatDispatch({
      type: _actions.UPDATE_DEV_SETTINGS,
      payload: settings
    });
  };

  var toggleWebchat = function toggleWebchat(toggle) {
    return webchatDispatch({
      type: _actions.TOGGLE_WEBCHAT,
      payload: toggle
    });
  };

  var toggleEmojiPicker = function toggleEmojiPicker(toggle) {
    return webchatDispatch({
      type: _actions.TOGGLE_EMOJI_PICKER,
      payload: toggle
    });
  };

  var togglePersistentMenu = function togglePersistentMenu(toggle) {
    return webchatDispatch({
      type: _actions.TOGGLE_PERSISTENT_MENU,
      payload: toggle
    });
  };

  var toggleCoverComponent = function toggleCoverComponent(toggle) {
    return webchatDispatch({
      type: _actions.TOGGLE_COVER_COMPONENT,
      payload: toggle
    });
  };

  var doRenderCustomComponent = function doRenderCustomComponent(toggle) {
    return webchatDispatch({
      type: _actions.DO_RENDER_CUSTOM_COMPONENT,
      payload: toggle
    });
  };

  var setError = function setError(error) {
    return webchatDispatch({
      type: _actions.SET_ERROR,
      payload: error
    });
  };

  var setOnline = function setOnline(online) {
    return webchatDispatch({
      type: _actions.SET_ONLINE,
      payload: online
    });
  };

  var clearMessages = function clearMessages() {
    webchatDispatch({
      type: _actions.CLEAR_MESSAGES
    });
  };

  var updateLastMessageDate = function updateLastMessageDate(date) {
    webchatDispatch({
      type: _actions.UPDATE_LAST_MESSAGE_DATE,
      payload: date
    });
  };

  var setCurrentAttachment = function setCurrentAttachment(attachment) {
    webchatDispatch({
      type: _actions.SET_CURRENT_ATTACHMENT,
      payload: attachment
    });
  };

  var updateJwt = function updateJwt(jwt) {
    webchatDispatch({
      type: _actions.UPDATE_JWT,
      payload: jwt
    });
  };

  return {
    webchatState: webchatState,
    webchatDispatch: webchatDispatch,
    addMessage: addMessage,
    addMessageComponent: addMessageComponent,
    updateMessage: updateMessage,
    updateReplies: updateReplies,
    updateLatestInput: updateLatestInput,
    updateTyping: updateTyping,
    updateWebview: updateWebview,
    updateSession: updateSession,
    updateLastRoutePath: updateLastRoutePath,
    updateHandoff: updateHandoff,
    updateTheme: updateTheme,
    updateDevSettings: updateDevSettings,
    toggleWebchat: toggleWebchat,
    toggleEmojiPicker: toggleEmojiPicker,
    togglePersistentMenu: togglePersistentMenu,
    toggleCoverComponent: toggleCoverComponent,
    doRenderCustomComponent: doRenderCustomComponent,
    setError: setError,
    setOnline: setOnline,
    clearMessages: clearMessages,
    updateLastMessageDate: updateLastMessageDate,
    setCurrentAttachment: setCurrentAttachment,
    updateJwt: updateJwt
  };
}

function useTyping(_ref) {
  var webchatState = _ref.webchatState,
      updateTyping = _ref.updateTyping,
      updateMessage = _ref.updateMessage,
      host = _ref.host;
  (0, _react.useEffect)(function () {
    var delayTimeout, typingTimeout;
    (0, _dom.scrollToBottom)({
      host: host
    });

    try {
      var nextMsg = webchatState.messagesJSON.filter(function (m) {
        return !m.display;
      })[0];

      if (nextMsg.delay && nextMsg.typing) {
        delayTimeout = setTimeout(function () {
          return updateTyping(true);
        }, nextMsg.delay * 1000);
      } else if (nextMsg.typing) updateTyping(true);

      var totalDelay = nextMsg.delay + nextMsg.typing;
      if (totalDelay) typingTimeout = setTimeout(function () {
        updateMessage(_objectSpread(_objectSpread({}, nextMsg), {}, {
          display: true
        }));
        updateTyping(false);
      }, totalDelay * 1000);
    } catch (e) {}

    return function () {
      clearTimeout(delayTimeout);
      clearTimeout(typingTimeout);
    };
  }, [webchatState.messagesJSON, webchatState.typing]);
}

function usePrevious(value) {
  var ref = (0, _react.useRef)();
  (0, _react.useEffect)(function () {
    ref.current = value;
  });
  return ref.current;
}

function useComponentVisible(initialIsVisible, onClickOutside) {
  var _useState = (0, _react.useState)(initialIsVisible),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      isComponentVisible = _useState2[0],
      setIsComponentVisible = _useState2[1];

  var ref = (0, _react.useRef)(null);

  var handleClickOutside = function handleClickOutside(event) {
    if (ref.current && !ref.current.contains(event.path[0])) {
      setIsComponentVisible(false);
      onClickOutside();
    }
  };

  (0, _react.useEffect)(function () {
    document.addEventListener('click', handleClickOutside, false);
    return function () {
      document.removeEventListener('click', handleClickOutside, false);
    };
  });
  return {
    ref: ref,
    isComponentVisible: isComponentVisible,
    setIsComponentVisible: setIsComponentVisible
  };
}

var useComponentWillMount = function useComponentWillMount(func) {
  (0, _react.useMemo)(func, []);
};

exports.useComponentWillMount = useComponentWillMount;
//# sourceMappingURL=hooks.js.map