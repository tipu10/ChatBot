"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createErrorBoundary = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _core = require("@botonic/core");

var _react = _interopRequireDefault(require("react"));

var _text = require("../components/text");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Replaces crashed children with the provided fallback component.
 * https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html
 * See alternative at https://stackoverflow.com/a/60255291/145289
 */
var createErrorBoundary = function createErrorBoundary() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$errorComponent = _ref.errorComponent,
      errorComponent = _ref$errorComponent === void 0 ? function (props) {
    return /*#__PURE__*/_react["default"].createElement(_text.Text, null, "The message cannot be displayed");
  } : _ref$errorComponent;

  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
    (0, _inherits2["default"])(ErrorBoundary, _React$Component);

    var _super = _createSuper(ErrorBoundary);

    function ErrorBoundary(props) {
      var _this;

      (0, _classCallCheck2["default"])(this, ErrorBoundary);
      _this = _super.call(this, props);
      _this.state = {
        error: null
      };
      return _this;
    }
    /**
     * @param error the exception which was trown
     * @param errorInfo the stack of component names at the error
     */


    (0, _createClass2["default"])(ErrorBoundary, [{
      key: "componentDidCatch",
      value: function componentDidCatch(error, errorInfo) {
        // No need to log the error because at least chrome & firefox already show
        // both component and call stacks
        if ((0, _core.isNode)()) {
          // In node, only the component stack is displayed
          console.error("Failure at:", error);
        }
      }
    }, {
      key: "render",
      value: function render() {
        if (this.state.error) {
          return errorComponent(_objectSpread(_objectSpread({}, this.props), {}, {
            errorMessage: this.state.error.message
          }));
        } else {
          return this.props.children;
        }
      }
    }], [{
      key: "getDerivedStateFromError",
      value: function getDerivedStateFromError(error) {
        return {
          error: error
        };
      }
    }]);
    return ErrorBoundary;
  }(_react["default"].Component);

  return ErrorBoundary;
};

exports.createErrorBoundary = createErrorBoundary;
//# sourceMappingURL=error-boundary.js.map