"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BotonicOutputTester = exports.BotonicInputTester = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@botonic/core");

var _react = _interopRequireDefault(require("react"));

var _server = _interopRequireDefault(require("react-dom/server"));

var _unescape = _interopRequireDefault(require("unescape"));

var _reply = require("./components/reply");

var _text2 = require("./components/text");

var BotonicInputTester = /*#__PURE__*/function () {
  function BotonicInputTester(bot) {
    (0, _classCallCheck2["default"])(this, BotonicInputTester);
    this.bot = bot;
  }

  (0, _createClass2["default"])(BotonicInputTester, [{
    key: "text",
    value: function () {
      var _text = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(inp) {
        var session,
            lastRoutePath,
            res,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                session = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                lastRoutePath = _args.length > 2 && _args[2] !== undefined ? _args[2] : '';
                _context.next = 4;
                return this.bot.input({
                  input: {
                    type: _core.INPUT.TEXT,
                    data: inp
                  },
                  session: session,
                  lastRoutePath: lastRoutePath
                });

              case 4:
                res = _context.sent;
                return _context.abrupt("return", (0, _unescape["default"])(res.response));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function text(_x) {
        return _text.apply(this, arguments);
      }

      return text;
    }()
  }, {
    key: "payload",
    value: function () {
      var _payload = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(inp) {
        var session,
            lastRoutePath,
            res,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                session = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                lastRoutePath = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : '';
                _context2.next = 4;
                return this.bot.input({
                  input: {
                    type: _core.INPUT.POSTBACK,
                    payload: inp
                  },
                  session: session,
                  lastRoutePath: lastRoutePath
                });

              case 4:
                res = _context2.sent;
                return _context2.abrupt("return", (0, _unescape["default"])(res.response));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function payload(_x2) {
        return _payload.apply(this, arguments);
      }

      return payload;
    }()
  }, {
    key: "path",
    value: function () {
      var _path = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(inp) {
        var session,
            lastRoutePath,
            res,
            _args3 = arguments;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                session = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                lastRoutePath = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : '';
                _context3.next = 4;
                return this.bot.input({
                  input: {
                    type: _core.INPUT.TEXT,
                    payload: "__PATH_PAYLOAD__".concat(inp)
                  },
                  session: session,
                  lastRoutePath: lastRoutePath
                });

              case 4:
                res = _context3.sent;
                return _context3.abrupt("return", (0, _unescape["default"])(res.response));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function path(_x3) {
        return _path.apply(this, arguments);
      }

      return path;
    }()
  }]);
  return BotonicInputTester;
}();

exports.BotonicInputTester = BotonicInputTester;

var BotonicOutputTester = /*#__PURE__*/function () {
  function BotonicOutputTester(bot) {
    (0, _classCallCheck2["default"])(this, BotonicOutputTester);
    this.bot = bot;
  }

  (0, _createClass2["default"])(BotonicOutputTester, [{
    key: "text",
    value: function text(out) {
      var replies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return (0, _unescape["default"])(_server["default"].renderToStaticMarkup(!replies ? /*#__PURE__*/_react["default"].createElement(_text2.Text, null, out) : /*#__PURE__*/_react["default"].createElement(_text2.Text, null, out, replies)));
    }
  }, {
    key: "reply",
    value: function reply(_ref) {
      var text = _ref.text,
          _ref$payload = _ref.payload,
          payload = _ref$payload === void 0 ? null : _ref$payload,
          _ref$path = _ref.path,
          path = _ref$path === void 0 ? null : _ref$path;

      if (payload) {
        return (0, _unescape["default"])(_server["default"].renderToStaticMarkup( /*#__PURE__*/_react["default"].createElement(_reply.Reply, {
          payload: payload
        }, text)));
      }

      if (path) {
        return (0, _unescape["default"])(_server["default"].renderToStaticMarkup( /*#__PURE__*/_react["default"].createElement(_reply.Reply, {
          path: path
        }, text)));
      }

      throw new Error('reply should contain a payload or a path');
    }
  }, {
    key: "replies",
    value: function replies() {
      var replies = [];

      for (var i = 0; i < arguments.length; i++) {
        var r = i < 0 || arguments.length <= i ? undefined : arguments[i];
        replies.push(this.reply({
          text: r.text,
          payload: r.payload,
          path: r.path
        }));
      }

      return replies;
    }
  }]);
  return BotonicOutputTester;
}();

exports.BotonicOutputTester = BotonicOutputTester;
//# sourceMappingURL=botonic-tester.js.map