"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Processor = void 0;
var tfjs_node_1 = require("@tensorflow/tfjs-node");
var constants_1 = require("../../../preprocess/constants");
var Processor = /** @class */ (function () {
    function Processor(preprocessor, tokensEncoder, intentEncoder) {
        this.preprocessor = preprocessor;
        this.tokensEncoder = tokensEncoder;
        this.intentEncoder = intentEncoder;
    }
    Processor.prototype.processSamples = function (samples) {
        var texts = samples.map(function (sample) { return sample.text; });
        var intents = samples.map(function (sample) { return sample.intent; });
        return { x: this.processTexts(texts), y: this.generateOutput(intents) };
    };
    Processor.prototype.processTexts = function (texts) {
        var _this = this;
        return tfjs_node_1.tensor(texts.map(function (text) { return _this.processText(text); }));
    };
    Processor.prototype.processText = function (text) {
        var sequence = this.generateSequence(text);
        return this.tokensEncoder.encode(sequence);
    };
    Processor.prototype.generateSequence = function (text) {
        var sequence = this.preprocessor.preprocess(text, constants_1.PADDING_TOKEN);
        return this.maskUnknownTokens(sequence);
    };
    Processor.prototype.maskUnknownTokens = function (sequence) {
        var _this = this;
        return sequence.map(function (token) {
            return _this.tokensEncoder.items.includes(token) ? token : constants_1.UNKNOWN_TOKEN;
        });
    };
    //TODO: modify encoders to just encode one token (not sequences).
    Processor.prototype.generateOutput = function (intents) {
        return tfjs_node_1.tensor(this.intentEncoder.encode(intents));
    };
    return Processor;
}());
exports.Processor = Processor;
//# sourceMappingURL=processor.js.map