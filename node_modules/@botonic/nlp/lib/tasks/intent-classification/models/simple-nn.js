"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSimpleNN = void 0;
var tfjs_node_1 = require("@tensorflow/tfjs-node");
var MODEL_NAME = 'SimpleIntentClassifier';
var DEFAULT_DROPOUT = 0.3;
var DEFAULT_UNITS = 128;
var DEFAULT_LEARNING_RATE = 0.001;
function createSimpleNN(maxLength, numIntents, embeddingsMatrix, params) {
    var _a, _b, _c;
    if (params === void 0) { params = {
        dropout: DEFAULT_DROPOUT,
        units: DEFAULT_UNITS,
        learningRate: DEFAULT_LEARNING_RATE,
    }; }
    var inputs = tfjs_node_1.input({ name: MODEL_NAME + "_InputLayer", shape: [maxLength] });
    var embeddingsLayer = tfjs_node_1.layers.embedding({
        name: MODEL_NAME + "_EmbeddingsLayer",
        inputDim: embeddingsMatrix.shape[0],
        outputDim: embeddingsMatrix.shape[1],
        inputLength: maxLength,
        weights: [embeddingsMatrix],
        trainable: true,
    });
    var lstmLayer = tfjs_node_1.layers.lstm({
        name: MODEL_NAME + "_LSTMLayer",
        units: (_a = params.units) !== null && _a !== void 0 ? _a : DEFAULT_UNITS,
        dropout: (_b = params.dropout) !== null && _b !== void 0 ? _b : DEFAULT_DROPOUT,
        recurrentDropout: 0.3,
    });
    var denseLayer = tfjs_node_1.layers.dense({
        name: MODEL_NAME + "_DenseLayer",
        units: numIntents,
        activation: 'softmax',
    });
    var outputs = denseLayer.apply(lstmLayer.apply(embeddingsLayer.apply(inputs)));
    var intentClassifierModel = tfjs_node_1.model({
        name: MODEL_NAME,
        inputs: inputs,
        outputs: outputs,
    });
    intentClassifierModel.compile({
        optimizer: tfjs_node_1.train.adam((_c = params.learningRate) !== null && _c !== void 0 ? _c : DEFAULT_LEARNING_RATE),
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy'],
    });
    return intentClassifierModel;
}
exports.createSimpleNN = createSimpleNN;
//# sourceMappingURL=simple-nn.js.map