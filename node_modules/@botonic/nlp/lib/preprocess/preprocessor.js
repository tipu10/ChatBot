"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Preprocessor = exports.SEQUENCE_POSITION = void 0;
var normalizer_1 = require("./engines/normalizer");
// import { getStemmer } from './engines/stemmer'
var stopwords_1 = require("./engines/stopwords");
var tokenizer_1 = require("./engines/tokenizer");
var SEQUENCE_POSITION;
(function (SEQUENCE_POSITION) {
    SEQUENCE_POSITION[SEQUENCE_POSITION["PRE"] = 0] = "PRE";
    SEQUENCE_POSITION[SEQUENCE_POSITION["POST"] = 1] = "POST";
})(SEQUENCE_POSITION = exports.SEQUENCE_POSITION || (exports.SEQUENCE_POSITION = {}));
var Preprocessor = /** @class */ (function () {
    function Preprocessor(locale, maxLength) {
        this.locale = locale;
        this.maxLength = maxLength;
        this.engines = {};
        this.loadEngines();
    }
    Preprocessor.prototype.loadEngines = function () {
        try {
            this.engines.normalizer = normalizer_1.getNormalizer(this.locale);
            this.engines.tokenizer = tokenizer_1.getTokenizer(this.locale);
            this.engines.stopwords = stopwords_1.getStopwords(this.locale);
            // this.engines.stemmer = getStemmer(this.locale)
        }
        catch (_a) {
            console.warn("Engines not implemented for locale \"" + this.locale + "\". Using default.");
        }
    };
    Preprocessor.prototype.preprocess = function (text, paddingValue) {
        var normalizedText = this.normalize(text);
        var tokens = this.tokenize(normalizedText);
        var filteredTokens = this.removeStopwords(tokens);
        var stemmedTokens = this.stem(filteredTokens);
        var paddedSequence = this.pad(stemmedTokens, paddingValue);
        var truncatedSequence = this.truncate(paddedSequence);
        return truncatedSequence;
    };
    Preprocessor.prototype.normalize = function (text) {
        return this.engines.normalizer
            ? this.engines.normalizer.normalize(text)
            : text.toLowerCase();
    };
    Preprocessor.prototype.tokenize = function (text) {
        return this.engines.tokenizer
            ? this.engines.tokenizer.tokenize(text)
            : text.split(' ');
    };
    Preprocessor.prototype.removeStopwords = function (tokens) {
        var _this = this;
        return this.engines.stopwords
            ? tokens.filter(function (t) { return !_this.engines.stopwords.includes(t); })
            : tokens;
    };
    Preprocessor.prototype.stem = function (tokens) {
        return this.engines.stemmer ? this.engines.stemmer.stem(tokens) : tokens;
    };
    Preprocessor.prototype.pad = function (tokens, value, position) {
        if (position === void 0) { position = SEQUENCE_POSITION.POST; }
        var difference = this.maxLength - tokens.length;
        if (difference > 0) {
            var padd = Array(difference).fill(value);
            return position === SEQUENCE_POSITION.PRE
                ? padd.concat(tokens)
                : tokens.concat(padd);
        }
        return tokens;
    };
    Preprocessor.prototype.truncate = function (tokens, position) {
        if (position === void 0) { position = SEQUENCE_POSITION.POST; }
        var difference = this.maxLength - tokens.length;
        if (difference < 0) {
            return position === SEQUENCE_POSITION.PRE
                ? tokens.slice(-this.maxLength)
                : tokens.slice(0, this.maxLength);
        }
        return tokens;
    };
    return Preprocessor;
}());
exports.Preprocessor = Preprocessor;
//# sourceMappingURL=preprocessor.js.map